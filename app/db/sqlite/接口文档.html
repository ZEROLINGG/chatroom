<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AsyncSQLiteDB 接口文档</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f4f4f4;
        }
        h1, h2, h3 {
            color: #333;
        }
        h1 {
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
        }
        h2 {
            margin-top: 20px;
            border-bottom: 1px solid #ccc;
            padding-bottom: 5px;
        }
        pre {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }
        code {
            font-family: Consolas, monospace;
        }
        .section {
            margin-bottom: 30px;
        }
        .method {
            background-color: #fff;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .method h3 {
            margin-top: 0;
            color: #007bff;
        }
        .param-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        .param-table th, .param-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .param-table th {
            background-color: #007bff;
            color: white;
        }
        .param-table tr:nth-child(even) {
            background-color: #f2f2f2;
        }
    </style>
</head>
<body>
<h1>AsyncSQLiteDB 接口文档</h1>
<p>本文档描述了 <code>AsyncSQLiteDB</code> 类的异步接口，用于管理 SQLite 数据库，提供高并发异步操作。基于 <code>aiosqlite</code> 库实现，适用于聊天应用程序的数据库操作。</p>

<div class="section">
    <h2>概述</h2>
    <p><code>AsyncSQLiteDB</code> 是一个异步 SQLite 数据库管理类，支持用户、房间、消息、私聊消息等功能。所有操作均异步执行，使用 <code>await</code> 关键字，适合高并发场景。数据库结构与同步版本保持一致，并通过异步上下文管理器确保连接安全。</p>
    <h3>数据库表结构</h3>
    <ul>
        <li><strong>user</strong>: 存储用户信息（UUID、QQ号、名称、角色等）。</li>
        <li><strong>room</strong>: 存储房间信息（UUID、名称、描述、创建者等）。</li>
        <li><strong>message</strong>: 存储群聊消息（消息UUID、发送者、内容、房间UUID等）。</li>
        <li><strong>private_message</strong>: 存储私聊消息（消息UUID、发送者、接收者、内容等）。</li>
        <li><strong>user_room</strong>: 存储用户与房间的关联关系（用户UUID、房间UUID、角色等）。</li>
        <li><strong>message_read_status</strong>: 存储消息阅读状态（用户UUID、消息UUID、阅读时间等）。</li>
    </ul>
</div>

<div class="section">
    <h2>接口列表</h2>

    <div class="method">
        <h3>init_database</h3>
        <p>异步初始化数据库，创建表结构和索引。如果表已存在，则不会重复创建。</p>
        <pre><code>async def init_database(self)</code></pre>
        <p><strong>参数</strong>: 无</p>
        <p><strong>返回</strong>: 无</p>
        <p><strong>说明</strong>: 初始化数据库，设置外键支持、WAL模式、同步模式和缓存大小，并创建必要的表和索引。</p>
    </div>

    <div class="method">
        <h3>get_connection</h3>
        <p>获取数据库连接的异步上下文管理器，每次调用创建一个新连接，确保线程安全和异步操作正确性。</p>
        <pre><code>@asynccontextmanager
async def get_connection(self) -> AsyncContextManager[aiosqlite.Connection]</code></pre>
        <p><strong>参数</strong>: 无</p>
        <p><strong>返回</strong>: <code>AsyncContextManager[aiosqlite.Connection]</code> - 异步数据库连接对象</p>
        <p><strong>说明</strong>: 使用上下文管理器获取数据库连接，自动处理连接的打开和关闭，并启用外键支持。</p>
    </div>

    <div class="method">
        <h3>execute_transaction</h3>
        <p>在单个事务中异步执行多个SQL操作。</p>
        <pre><code>async def execute_transaction(self, operations: List[tuple]) -> bool</code></pre>
        <p><strong>参数</strong>:</p>
        <table class="param-table">
            <tr>
                <th>参数</th>
                <th>类型</th>
                <th>描述</th>
            </tr>
            <tr>
                <td>operations</td>
                <td>List[tuple]</td>
                <td>操作列表，每个元素为 (sql, params) 元组，sql 为 SQL 语句，params 为参数</td>
            </tr>
        </table>
        <p><strong>返回</strong>: <code>bool</code> - 成功返回 True，失败返回 False</p>
        <p><strong>说明</strong>: 在事务中执行多个 SQL 操作，失败时自动回滚。</p>
    </div>

    <div class="method">
        <h3>vacuum_database</h3>
        <p>异步清理数据库，重建并回收未使用的空间。</p>
        <pre><code>async def vacuum_database(self)</code></pre>
        <p><strong>参数</strong>: 无</p>
        <p><strong>返回</strong>: 无</p>
        <p><strong>说明</strong>: 执行 SQLite 的 VACUUM 命令，优化数据库存储空间。</p>
    </div>

    <div class="method">
        <h3>analyze_database</h3>
        <p>异步分析数据库，更新统计信息以帮助查询规划器优化查询。</p>
        <pre><code>async def analyze_database(self)</code></pre>
        <p><strong>参数</strong>: 无</p>
        <p><strong>返回</strong>: 无</p>
        <p><strong>说明</strong>: 执行 SQLite 的 ANALYZE 命令，优化查询性能。</p>
    </div>

    <div class="method">
        <h3>get_database_info</h3>
        <p>异步获取数据库元信息，如大小和表中的行数。</p>
        <pre><code>async def get_database_info(self) -> dict</code></pre>
        <p><strong>参数</strong>: 无</p>
        <p><strong>返回</strong>: <code>dict</code> - 包含数据库大小（database_size_bytes）和各表行数（tables）的字典</p>
        <p><strong>说明</strong>: 返回数据库的元信息，包括总大小和每个表的记录数。</p>
    </div>

    <div class="method">
        <h3>create_user</h3>
        <p>异步创建用户。</p>
        <pre><code>async def create_user(self, user_data: Dict[str, Any]) -> str</code></pre>
        <p><strong>参数</strong>:</p>
        <table class="param-table">
            <tr>
                <th>参数</th>
                <th>类型</th>
                <th>描述</th>
            </tr>
            <tr>
                <td>user_data</td>
                <td>Dict[str, Any]</td>
                <td>用户数据字典，包含 qq_number、name、avatar_path、role、password_hash、inviter 等字段</td>
            </tr>
        </table>
        <p><strong>返回</strong>: <code>str</code> - 创建的用户 UUID，失败返回空字符串</p>
        <p><strong>说明</strong>: 创建新用户并返回其 UUID，自动生成 created_at 和 updated_at 时间戳。</p>
    </div>

    <div class="method">
        <h3>get_user_by_uuid</h3>
        <p>异步根据 UUID 获取用户信息。</p>
        <pre><code>async def get_user_by_uuid(self, user_uuid: str) -> Optional[Dict[str, Any]]</code></pre>
        <p><strong>参数</strong>:</p>
        <table class="param-table">
            <tr>
                <th>参数</th>
                <th>类型</th>
                <th>描述</th>
            </tr>
            <tr>
                <td>user_uuid</td>
                <td>str</td>
                <td>用户 UUID</td>
            </tr>
        </table>
        <p><strong>返回</strong>: <code>Optional[Dict[str, Any]]</code> - 用户信息字典，不存在返回 None</p>
        <p><strong>说明</strong>: 查询活跃用户的详细信息，仅返回 is_active = 1 的用户。</p>
    </div>

    <div class="method">
        <h3>get_user_by_qq_number</h3>
        <p>异步根据 QQ 号获取用户信息。</p>
        <pre><code>async def get_user_by_qq_number(self, qq_number: str) -> Optional[Dict[str, Any]]</code></pre>
        <p><strong>参数</strong>:</p>
        <table class="param-table">
            <tr>
                <th>参数</th>
                <th>类型</th>
                <th>描述</th>
            </tr>
            <tr>
                <td>qq_number</td>
                <td>str</td>
                <td>用户的 QQ 号</td>
            </tr>
        </table>
        <p><strong>返回</strong>: <code>Optional[Dict[str, Any]]</code> - 用户信息字典，不存在或不活跃返回 None</p>
        <p><strong>说明</strong>: 根据 QQ 号查询活跃用户，仅返回 is_active = 1 的用户。</p>
    </div>

    <div class="method">
        <h3>update_user</h3>
        <p>异步更新用户信息。</p>
        <pre><code>async def update_user(self, user_uuid: str, update_data: Dict[str, Any]) -> bool</code></pre>
        <p><strong>参数</strong>:</p>
        <table class="param-table">
            <tr>
                <th>参数</th>
                <th>类型</th>
                <th>描述</th>
            </tr>
            <tr>
                <td>user_uuid</td>
                <td>str</td>
                <td>用户 UUID</td>
            </tr>
            <tr>
                <td>update_data</td>
                <td>Dict[str, Any]</td>
                <td>要更新的数据字典，键为字段名，值为更新值</td>
            </tr>
        </table>
        <p><strong>返回</strong>: <code>bool</code> - 更新成功返回 True，失败返回 False</p>
        <p><strong>说明</strong>: 动态更新用户信息，自动更新 updated_at 时间戳。</p>
    </div>

    <div class="method">
        <h3>create_room</h3>
        <p>异步创建房间。</p>
        <pre><code>async def create_room(self, room_data: Dict[str, Any]) -> str</code></pre>
        <p><strong>参数</strong>:</p>
        <table class="param-table">
            <tr>
                <th>参数</th>
                <th>类型</th>
                <th>描述</th>
            </tr>
            <tr>
                <td>room_data</td>
                <td>Dict[str, Any]</td>
                <td>房间数据字典，包含 name、description、avatar_path、max_online_users、max_join_users、creator 等字段</td>
            </tr>
        </table>
        <p><strong>返回</strong>: <code>str</code> - 创建的房间 UUID，失败返回空字符串</p>
        <p><strong>说明</strong>: 创建房间并将创建者添加为房间所有者，自动生成 created_at 和 updated_at 时间戳。</p>
    </div>

    <div class="method">
        <h3>send_message</h3>
        <p>异步发送消息到房间。</p>
        <pre><code>async def send_message(self, message_data: Dict[str, Any]) -> str</code></pre>
        <p><strong>参数</strong>:</p>
        <table class="param-table">
            <tr>
                <th>参数</th>
                <th>类型</th>
                <th>描述</th>
            </tr>
            <tr>
                <td>message_data</td>
                <td>Dict[str, Any]</td>
                <td>消息数据字典，包含 sender、msg_type、content、room_uuid、reply_to、file_path、file_size 等字段</td>
            </tr>
        </table>
        <p><strong>返回</strong>: <code>str</code> - 创建的消息 UUID，失败返回空字符串</p>
        <p><strong>说明</strong>: 发送群聊消息并返回消息 UUID，自动生成 created_at 时间戳。</p>
    </div>

    <div class="method">
        <h3>get_room_messages</h3>
        <p>异步获取房间消息（分页）。</p>
        <pre><code>async def get_room_messages(self, room_uuid: str, limit: int = 50, offset: int = 0) -> List[Dict[str, Any]]</code></pre>
        <p><strong>参数</strong>:</p>
        <table class="param-table">
            <tr>
                <th>参数</th>
                <th>类型</th>
                <th>描述</th>
            </tr>
            <tr>
                <td>room_uuid</td>
                <td>str</td>
                <td>房间 UUID</td>
            </tr>
            <tr>
                <td>limit</td>
                <td>int</td>
                <td>每页消息数量，默认 50</td>
            </tr>
            <tr>
                <td>offset</td>
                <td>int</td>
                <td>偏移量，默认 0</td>
            </tr>
        </table>
        <p><strong>返回</strong>: <code>List[Dict[str, Any]]</code> - 消息列表，每个消息包含详细信息</p>
        <p><strong>说明</strong>: 分页获取房间内未删除的消息，包含发送者名称和头像，按创建时间倒序排列。</p>
    </div>

    <div class="method">
        <h3>send_private_message</h3>
        <p>异步发送私聊消息。</p>
        <pre><code>async def send_private_message(self, message_data: Dict[str, Any]) -> str</code></pre>
        <p><strong>参数</strong>:</p>
        <table class="param-table">
            <tr>
                <th>参数</th>
                <th>类型</th>
                <th>描述</th>
            </tr>
            <tr>
                <td>message_data</td>
                <td>Dict[str, Any]</td>
                <td>私聊消息数据字典，包含 sender_uuid、receiver_uuid、msg_type、content、reply_to、file_path、file_size 等字段</td>
            </tr>
        </table>
        <p><strong>返回</strong>: <code>str</code> - 创建的消息 UUID，失败返回空字符串</p>
        <p><strong>说明</strong>: 发送私聊消息并返回消息 UUID，自动生成 created_at 时间戳。</p>
    </div>

    <div class="method">
        <h3>get_private_message_users</h3>
        <p>获取与指定用户有私聊记录的用户列表。</p>
        <pre><code>async def get_private_message_users(self, user_uuid: str) -> List[str]</code></pre>
        <p><strong>参数</strong>:</p>
        <table class="param-table">
            <tr>
                <th>参数</th>
                <th>类型</th>
                <th>描述</th>
            </tr>
            <tr>
                <td>user_uuid</td>
                <td>str</td>
                <td>用户 UUID</td>
            </tr>
        </table>
        <p><strong>返回</strong>: <code>List[str]</code> - 与该用户有私聊记录的用户 UUID 列表</p>
        <p><strong>说明</strong>: 返回与指定用户有过私聊的唯一用户 UUID 列表。</p>
    </div>

    <div class="method">
        <h3>get_private_messages</h3>
        <p>异步获取两个用户之间的私聊消息（分页）。</p>
        <pre><code>async def get_private_messages(self, user_uuid1: str, user_uuid2: str, limit: int = 50, offset: int = 0) -> List[Dict[str, Any]]</code></pre>
        <p><strong>参数</strong>:</p>
        <table class="param-table">
            <tr>
                <th>参数</th>
                <th>类型</th>
                <th>描述</th>
            </tr>
            <tr>
                <td>user_uuid1</td>
                <td>str</td>
                <td>用户1 UUID</td>
            </tr>
            <tr>
                <td>user_uuid2</td>
                <td>str</td>
                <td>用户2 UUID</td>
            </tr>
            <tr>
                <td>limit</td>
                <td>int</td>
                <td>每页消息数量，默认 50</td>
            </tr>
            <tr>
                <td>offset</td>
                <td>int</td>
                <td>偏移量，默认 0</td>
            </tr>
        </table>
        <p><strong>返回</strong>: <code>List[Dict[str, Any]]</code> - 私聊消息列表，每个消息包含详细信息</p>
        <p><strong>说明</strong>: 分页获取两个用户之间的未删除私聊消息，包含发送者和接收者的名称及头像，按创建时间倒序排列。</p>
    </div>

    <div class="method">
        <h3>join_room</h3>
        <p>异步用户加入房间。</p>
        <pre><code>async def join_room(self, user_uuid: str, room_uuid: str) -> bool</code></pre>
        <p><strong>参数</strong>:</p>
        <table class="param-table">
            <tr>
                <th>参数</th>
                <th>类型</th>
                <th>描述</th>
            </tr>
            <tr>
                <td>user_uuid</td>
                <td>str</td>
                <td>用户 UUID</td>
            </tr>
            <tr>
                <td>room_uuid</td>
                <td>str</td>
                <td>房间 UUID</td>
            </tr>
        </table>
        <p><strong>返回</strong>: <code>bool</code> - 加入成功返回 True，失败返回 False</p>
        <p><strong>说明</strong>: 用户加入房间，角色默认为 member，自动设置 joined_at 时间戳。</p>
    </div>

    <div class="method">
        <h3>leave_room</h3>
        <p>异步用户退出房间。</p>
        <pre><code>async def leave_room(self, user_uuid: str, room_uuid: str) -> bool</code></pre>
        <p><strong>参数</strong>:</p>
        <table class="param-table">
            <tr>
                <th>参数</th>
                <th>类型</th>
                <th>描述</th>
            </tr>
            <tr>
                <td>user_uuid</td>
                <td>str</td>
                <td>用户 UUID</td>
            </tr>
            <tr>
                <td>room_uuid</td>
                <td>str</td>
                <td>房间 UUID</td>
            </tr>
        </table>
        <p><strong>返回</strong>: <code>bool</code> - 退出成功返回 True，失败返回 False</p>
        <p><strong>说明</strong>: 用户退出房间，设置 left_at 时间戳，仅更新 left_at 为空的记录。</p>
    </div>
</div>

<div class="section">
    <h2>使用示例</h2>
    <p>以下是使用 <code>AsyncSQLiteDB</code> 类的示例代码，展示如何初始化数据库、创建用户、创建房间、发送消息等操作：</p>
    <pre><code>
async def example_usage():
    """异步数据库操作的使用示例"""
    db = AsyncSQLiteDB("async_chat.db")

    # 初始化数据库
    await db.init_database()

    # 创建用户
    user_data = {
        'qq_number': '12345678',
        'name': '测试用户',
        'role': 'user'
    }
    user_uuid = await db.create_user(user_data)
    print(f"创建用户: {user_uuid}")

    # 获取用户信息
    user_info = await db.get_user_by_uuid(user_uuid)
    print(f"用户信息: {user_info}")

    # 创建房间
    room_data = {
        'name': '测试房间',
        'description': '这是一个测试房间',
        'creator': user_uuid
    }
    room_uuid = await db.create_room(room_data)
    print(f"创建房间: {room_uuid}")

    # 发送消息
    message_data = {
        'sender': user_uuid,
        'content': '这是一条测试消息',
        'room_uuid': room_uuid
    }
    msg_uuid = await db.send_message(message_data)
    print(f"发送消息: {msg_uuid}")

    # 获取房间消息
    messages = await db.get_room_messages(room_uuid)
    print(f"房间消息: {messages}")

    # 获取数据库信息
    db_info = await db.get_database_info()
    print(f"数据库信息: {db_info}")

# 运行示例
asyncio.run(example_usage())
        </code></pre>
</div>

<div class="section">
    <h2>注意事项</h2>
    <ul>
        <li>所有数据库操作均为异步，需使用 <code>await</code> 调用。</li>
        <li>使用 <code>get_connection</code> 方法确保连接安全管理。</li>
        <li>数据库表结构与同步版本一致，方便同步和异步代码切换。</li>
        <li>自动创建索引以提升查询性能，适用于高并发场景。</li>
        <li>错误处理通过日志记录，建议结合日志监控系统使用。</li>
    </ul>
</div>
</body>
</html>